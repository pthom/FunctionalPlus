// Copyright 2015, Tobias Hermann and the FunctionalPlus contributors.
// https://github.com/Dobiasd/FunctionalPlus
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt)

#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include "doctest.h"

#include <vector>
#include <fplus/fplus.hpp>
#include <fplus/benchmark_session.hpp>

fplus::benchmark_session my_benchmark_session;


// In this example, we are benchmarking gemstones_bench, 
// and only benchmark 2 sub-functions : split_lines and convert_container
std::string gemstones_bench(const std::string& input)
{
    using namespace fplus;

    typedef std::set<std::string::value_type> character_set;

    // Benchmark by replacing a function:
    // Below, we will benchmark the call to split_lines:
    // // const auto lines = split_lines(false, input); // this was the original code 
    // 1. we define an alternate version split_lines_bench
    auto split_lines_bench = make_benchmark_function(my_benchmark_session, "split_lines", split_lines<std::string>);
    // 2. we replace the call by using the alternate version
    const auto lines = split_lines_bench(false, input); // replace call with benchmarked version

    // Benchmark by replacing an expression
    // Below, we will benchmark an expression
    // The original expression was:
    // const auto sets = transform( convert_container<character_set, std::string>, lines);
    // We just copy paste this expression into the bench_expression macro, like shown below
    // Note: since this is a macro we must replace the ',' by COMMA
    const auto sets = benchmark_expression(
        my_benchmark_session, 
        "transform", 
        transform(convert_container<character_set, std::string> COMMA lines)
    );

    // Build the intersection of all character sets.
    const auto gem_elements = fold_left_1(
        set_intersection<character_set>, sets);

    // Convert gem_elements.size() into a std::string.
    return show(size_of_cont(gem_elements));
}

TEST_CASE("my_benchmark")
{
    std::string input("Lorem ipsum\ndolor sit amet,\nconsectetur,\nadipisci velit");
    fplus::run_n_times(1000, [&]() { gemstones_bench(input); });

    // Will output something like
    // Function   |Nb calls|Total time|Av. time|Deviation|
    // -----------+--------+----------+--------+---------+
    // transform  |    1000|   4.828ms| 4.828ns|  2.473ns|
    // split_lines|    1000|   3.795ms| 3.795ns|  2.729ns|
    std::cout << fplus::show(my_benchmark_session.report());
}

fplus::benchmark_session my_benchmark_session2;

int sort_example()
{
    using Ints = std::vector<int>;

    Ints ascending_numbers = benchmark_expression(
        my_benchmark_session2,
        "ascending",
        fplus::numbers(0 COMMA 1000);
    );
    Ints shuffled_numbers = benchmark_expression(
        my_benchmark_session2,
        "shuffle",
        fplus::shuffle(std::mt19937::default_seed, ascending_numbers);
    );

    auto sort_func = [](const Ints& values) { return fplus::sort(values); };
    auto sort_bench = fplus::make_benchmark_function(my_benchmark_session2, "sort", sort_func);

    auto sorted_numbers = sort_bench(shuffled_numbers);
    // sorting 1000 numbers should require less than 0.1 seconds (in practice it requires about 0.2ms)

    return 1;
}

TEST_CASE("my_benchmark2")
{
    auto sort_example_bench = make_benchmark_function(my_benchmark_session2, "sort_example", sort_example);
    fplus::run_n_times(1000, [&]() { sort_example_bench(); });
    std::cout << fplus::show(my_benchmark_session2.report());
}

